import { jaroWrinkerSimilarity } from './string-similarity';
import { resolvePointer, Condition, testPointerCondition, JSONObject, JSONValue, JSONArray } from './utils';

export interface PotentialMatch {
    leftElementIndex: number;
    rightElementIndex: number;
    confidence?: number; // only used in similarity functions
}

/**
 * Instructions generated by a constraint that tell the comparator how to match up indices of an array pair.
 */
export interface MatchInstructions {
    matchedIndices: PotentialMatch[];
    unmatchedLeftIndices: number[];
    unmatchedRightIndices: number[];
}

export type MatchType = 'literal' | 'string-similarity';

type ConstraintConditionTuple = [Condition, AbstractMatchConstraint];

/**
 * This object houses match constraints and provides the ability to search
 * through all the match constraints.
 */
export class MatchConstraintsContainer {
    private constraints: ConstraintConditionTuple[];

    public tryGetConstraint(pointer: string): AbstractMatchConstraint | null {
        for (const constraint of this.constraints) {
            if (testPointerCondition(pointer, constraint[0])) {
                return constraint[1];
            }
        }
        return null;
    }

    constructor(constraints: ConstraintConditionTuple[]) {
        this.constraints = constraints;
    }

    /**
     * Create constraints container from dictionary.
     * This object should be a map from the `condition` to the `constraint`,
     * where each condition is a string and each `constraint` is an object.
     * @param obj Dictionary (parsed JSON/YAML) object
     */
    public static fromDict(obj: JSONObject): MatchConstraintsContainer {
        const constraints: ConstraintConditionTuple[] = [];
        for (const condition of Object.getOwnPropertyNames(obj ?? {})) {
            const constraint = MatchConstraintFromDict(obj[condition] as JSONObject);
            const constraintTuple = [condition, constraint] as ConstraintConditionTuple;
            constraints.push(constraintTuple);
        }
        return new MatchConstraintsContainer(constraints);
    }
}

function MatchConstraintFromDict(obj: JSONObject): AbstractMatchConstraint {
    if (!Object.prototype.hasOwnProperty.call(obj, 'type')) {
        throw new Error(`Error decoding object ${obj} into MatchConstraint`);
    }

    switch (obj['type'] as string) {
        case PrimitiveMatchConstraint.name:
            return PrimitiveMatchConstraint.fromDict(obj);
        case ObjectPropertyMatchConstraint.name:
            return ObjectPropertyMatchConstraint.fromDict(obj);
        default:
            throw new Error(`Unknown match constraint: ${obj['type']}`);
    }
}

export abstract class AbstractMatchConstraint {
    abstract scoreElementPair(leftElement: JSONValue, rightElement: JSONValue): number;

    public matchArrayElements(leftArray: JSONArray, rightArray: JSONArray): MatchInstructions {
        const instructions: MatchInstructions = {
            matchedIndices: [],
            unmatchedLeftIndices: [],
            unmatchedRightIndices: [],
        };

        const rightArrayIndices = [...rightArray.keys()];
        for (let leftElementIndex = 0; leftElementIndex < leftArray.length; leftElementIndex++) {
            const leftElement = leftArray[leftElementIndex];
            let topScore = 0;
            let topScoreIndex = -1;
            for (const rightElementIndex of rightArrayIndices) {
                const rightElement = rightArray[rightElementIndex];
                const score = this.scoreElementPair(leftElement, rightElement);
                if (score > topScore) {
                    topScore = score;
                    topScoreIndex = rightElementIndex;
                    if (score === 1) break;
                }
            }
            if (topScoreIndex === -1) {
                instructions.unmatchedLeftIndices.push(leftElementIndex);
            } else {
                const deleteIndex = rightArrayIndices.indexOf(topScoreIndex);
                rightArrayIndices.splice(deleteIndex, 1);
                instructions.matchedIndices.push({
                    leftElementIndex,
                    rightElementIndex: topScoreIndex,
                    confidence: topScore,
                });
            }
        }

        instructions.unmatchedRightIndices = rightArrayIndices;

        return instructions;
    }

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    public static fromDict(_: JSONObject): AbstractMatchConstraint {
        throw new Error('Not implemented');
    }
}

export class PrimitiveMatchConstraint extends AbstractMatchConstraint {
    matchType: MatchType;

    scoreElementPair(leftElement: JSONValue, rightElement: JSONValue): number {
        if (this.matchType === 'literal') {
            return leftElement === rightElement ? 1 : 0;
        } else if (this.matchType === 'string-similarity') {
            return jaroWrinkerSimilarity(leftElement as string, rightElement as string);
        } else {
            throw new Error('unknown comparison type');
        }
    }

    public constructor(matchType: MatchType) {
        super();
        this.matchType = matchType;
    }

    public static fromDict(obj: JSONObject): AbstractMatchConstraint {
        if (!Object.prototype.hasOwnProperty.call(obj, 'matchType')) {
            throw new Error(`Error decoding object ${obj} into ${ObjectPropertyMatchConstraint.name}`);
        }

        return new PrimitiveMatchConstraint(obj['matchType'] as MatchType);
    }
}

export class ObjectPropertyMatchConstraint extends AbstractMatchConstraint {
    matchType: MatchType;
    propertyName: string;
    secondaryProperties?: string;

    scoreElementPair(leftElement: JSONObject, rightElement: JSONObject): number {
        if (this.secondaryProperties) {
            for (const secondaryProperty of this.secondaryProperties) {
                if (leftElement[secondaryProperty] !== rightElement[secondaryProperty]) {
                    return 0;
                }
            }
        }

        try {
            const leftSubProperty = resolvePointer(leftElement, this.propertyName);
            const rightSubProperty = resolvePointer(rightElement, this.propertyName);

            if (this.matchType === 'literal') {
                return leftSubProperty === rightSubProperty ? 1 : 0;
            } else if (this.matchType === 'string-similarity') {
                return jaroWrinkerSimilarity(leftSubProperty as string, rightSubProperty as string);
            } else {
                throw new Error('unknown comparison type');
            }
        } catch (error) {
            return 0;
        }
    }

    public constructor(matchType: MatchType, propertyName: string, secondaryProperties?: string) {
        super();
        this.matchType = matchType;
        this.propertyName = propertyName;
        this.secondaryProperties = secondaryProperties;
    }

    public static fromDict(obj: JSONObject): AbstractMatchConstraint {
        if (
            !Object.prototype.hasOwnProperty.call(obj, 'matchType') ||
            !Object.prototype.hasOwnProperty.call(obj, 'propertyName') ||
            !Object.prototype.hasOwnProperty.call(obj, 'secondaryProperties')
        ) {
            throw new Error(`Error decoding object ${obj} into ${ObjectPropertyMatchConstraint.name}`);
        }

        return new ObjectPropertyMatchConstraint(
            obj['matchType'] as MatchType,
            obj['propertyName'] as string,
            obj['secondaryProperties'] as string | undefined,
        );
    }
}
